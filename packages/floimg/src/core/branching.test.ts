/**
 * Tests for branching pipeline execution (fan-out, collect, router)
 *
 * These tests validate the SDK-level support for parallel branching workflows.
 * The same primitives are used by Studio, CLI, and MCP for end-to-end consistency.
 */

import { describe, it, expect, beforeEach } from "vitest";
import type {
  PipelineStep,
  ImageBlob,
  DataBlob,
  Pipeline,
  ImageGenerator,
  TextProvider,
} from "./types.js";
import { buildDependencyGraph, computeExecutionWaves } from "./pipeline-runner.js";
import { FloImg } from "./client.js";

// Helper to create mock ImageBlob
function mockImageBlob(id: string): ImageBlob {
  return {
    bytes: Buffer.from(`mock-image-${id}`),
    mime: "image/png",
    width: 100,
    height: 100,
    source: `test:${id}`,
  };
}

// Helper to create mock DataBlob
function mockDataBlob(content: string, parsed?: Record<string, unknown>): DataBlob {
  return {
    type: parsed ? "json" : "text",
    content,
    parsed,
    source: "test:data",
  };
}

describe("buildDependencyGraph", () => {
  describe("fan-out step", () => {
    it("should identify fan-out input as dependency", () => {
      const steps: PipelineStep[] = [
        { kind: "generate", generator: "test", out: "source" },
        {
          kind: "fan-out",
          in: "source",
          mode: "count",
          count: 3,
          out: ["branch_0", "branch_1", "branch_2"],
        },
      ];

      const graph = buildDependencyGraph(steps);

      expect(graph[1].dependencies).toContain("source");
      expect(graph[1].outputs).toEqual(["branch_0", "branch_1", "branch_2"]);
    });

    it("should handle array mode fan-out", () => {
      const steps: PipelineStep[] = [
        { kind: "text", provider: "test", params: { prompt: "test" }, out: "concepts" },
        {
          kind: "fan-out",
          in: "concepts",
          mode: "array",
          arrayProperty: "items",
          out: ["item_0", "item_1"],
        },
      ];

      const graph = buildDependencyGraph(steps);

      expect(graph[1].dependencies).toContain("concepts");
      expect(graph[1].outputs).toEqual(["item_0", "item_1"]);
    });
  });

  describe("collect step", () => {
    it("should identify all inputs as dependencies", () => {
      const steps: PipelineStep[] = [
        { kind: "generate", generator: "test", out: "img_0" },
        { kind: "generate", generator: "test", out: "img_1" },
        { kind: "generate", generator: "test", out: "img_2" },
        {
          kind: "collect",
          in: ["img_0", "img_1", "img_2"],
          waitMode: "all",
          out: "all_images",
        },
      ];

      const graph = buildDependencyGraph(steps);

      expect(graph[3].dependencies).toContain("img_0");
      expect(graph[3].dependencies).toContain("img_1");
      expect(graph[3].dependencies).toContain("img_2");
      expect(graph[3].outputs).toEqual(["all_images"]);
    });
  });

  describe("router step", () => {
    it("should identify both candidates and selection as dependencies", () => {
      const steps: PipelineStep[] = [
        { kind: "generate", generator: "test", out: "candidates" },
        { kind: "text", provider: "test", params: { prompt: "pick" }, out: "selection" },
        {
          kind: "router",
          in: "candidates",
          selectionIn: "selection",
          selectionType: "index",
          selectionProperty: "winner",
          out: "winner",
        },
      ];

      const graph = buildDependencyGraph(steps);

      expect(graph[2].dependencies).toContain("candidates");
      expect(graph[2].dependencies).toContain("selection");
      expect(graph[2].outputs).toEqual(["winner"]);
    });
  });
});

describe("computeExecutionWaves", () => {
  it("should execute fan-out after its input is ready", () => {
    const steps: PipelineStep[] = [
      { kind: "generate", generator: "test", out: "source" },
      {
        kind: "fan-out",
        in: "source",
        mode: "count",
        count: 3,
        out: ["b_0", "b_1", "b_2"],
      },
    ];

    const graph = buildDependencyGraph(steps);
    const waves = computeExecutionWaves(graph);

    expect(waves).toHaveLength(2);
    expect(waves[0].steps.map((s) => s.step.kind)).toEqual(["generate"]);
    expect(waves[1].steps.map((s) => s.step.kind)).toEqual(["fan-out"]);
  });

  it("should execute collect after all branch inputs are ready", () => {
    const steps: PipelineStep[] = [
      { kind: "generate", generator: "test", out: "source" },
      {
        kind: "fan-out",
        in: "source",
        mode: "count",
        count: 3,
        out: ["b_0", "b_1", "b_2"],
      },
      // These would normally be generated by downstream steps
      // For this test, we simulate branches completing
      {
        kind: "collect",
        in: ["b_0", "b_1", "b_2"],
        waitMode: "all",
        out: "collected",
      },
    ];

    const graph = buildDependencyGraph(steps);
    const waves = computeExecutionWaves(graph);

    // Wave 1: generate
    // Wave 2: fan-out
    // Wave 3: collect (waits for all fan-out outputs)
    expect(waves).toHaveLength(3);
    expect(waves[2].steps.map((s) => s.step.kind)).toEqual(["collect"]);
  });

  it("should execute router after both candidates and selection are ready", () => {
    const steps: PipelineStep[] = [
      { kind: "generate", generator: "test", out: "candidates" },
      { kind: "text", provider: "test", params: { prompt: "pick" }, out: "selection" },
      {
        kind: "router",
        in: "candidates",
        selectionIn: "selection",
        selectionType: "index",
        selectionProperty: "winner",
        out: "winner",
      },
    ];

    const graph = buildDependencyGraph(steps);
    const waves = computeExecutionWaves(graph);

    // Wave 1: generate + text (parallel, no deps)
    // Wave 2: router (depends on both)
    expect(waves).toHaveLength(2);
    expect(waves[0].steps).toHaveLength(2);
    expect(waves[1].steps.map((s) => s.step.kind)).toEqual(["router"]);
  });

  it("should handle complete fan-out → process → collect → router pipeline", () => {
    const steps: PipelineStep[] = [
      // 0: Generate source
      { kind: "generate", generator: "test", out: "source" },
      // 1: Fan out to 3 branches
      {
        kind: "fan-out",
        in: "source",
        mode: "count",
        count: 3,
        out: ["b_0", "b_1", "b_2"],
      },
      // 2-4: Transform each branch (simulating parallel image generation)
      { kind: "transform", op: "resize", in: "b_0", params: { width: 100 }, out: "t_0" },
      { kind: "transform", op: "resize", in: "b_1", params: { width: 100 }, out: "t_1" },
      { kind: "transform", op: "resize", in: "b_2", params: { width: 100 }, out: "t_2" },
      // 5: Collect results
      {
        kind: "collect",
        in: ["t_0", "t_1", "t_2"],
        waitMode: "all",
        out: "all_results",
      },
      // 6: Evaluate with vision (simulated as text for test)
      {
        kind: "text",
        provider: "test",
        in: "all_results",
        params: { prompt: "eval" },
        out: "eval",
      },
      // 7: Route to winner
      {
        kind: "router",
        in: "all_results",
        selectionIn: "eval",
        selectionType: "index",
        selectionProperty: "winner",
        out: "winner",
      },
    ];

    const graph = buildDependencyGraph(steps);
    const waves = computeExecutionWaves(graph);

    // Wave 1: generate
    // Wave 2: fan-out
    // Wave 3: transform x3 (parallel!)
    // Wave 4: collect
    // Wave 5: text (eval)
    // Wave 6: router
    expect(waves).toHaveLength(6);

    // Verify transforms run in parallel (same wave)
    const transformWave = waves.find((w) => w.steps.some((s) => s.step.kind === "transform"));
    expect(transformWave?.steps).toHaveLength(3);
  });
});

describe("fan-out execution", () => {
  describe("count mode", () => {
    it("should distribute input to all branches", async () => {
      // This will test actual execution once implemented
      const fanOutStep: PipelineStep = {
        kind: "fan-out",
        in: "source",
        mode: "count",
        count: 3,
        out: ["b_0", "b_1", "b_2"],
      };

      // The step should create 3 copies of the input
      expect(fanOutStep.out).toHaveLength(3);
      expect(fanOutStep.mode).toBe("count");
    });
  });

  describe("array mode", () => {
    it("should distribute array items to branches", async () => {
      const fanOutStep: PipelineStep = {
        kind: "fan-out",
        in: "concepts",
        mode: "array",
        arrayProperty: "items",
        out: ["item_0", "item_1", "item_2"],
      };

      expect(fanOutStep.mode).toBe("array");
      expect(fanOutStep.arrayProperty).toBe("items");
    });
  });
});

describe("collect execution", () => {
  it("should gather all inputs when waitMode is 'all'", async () => {
    const collectStep: PipelineStep = {
      kind: "collect",
      in: ["img_0", "img_1", "img_2"],
      waitMode: "all",
      out: "collected",
    };

    expect(collectStep.waitMode).toBe("all");
    expect(collectStep.in).toHaveLength(3);
  });

  it("should accept partial results when waitMode is 'available'", async () => {
    const collectStep: PipelineStep = {
      kind: "collect",
      in: ["img_0", "img_1", "img_2"],
      waitMode: "available",
      minRequired: 2,
      out: "collected",
    };

    expect(collectStep.waitMode).toBe("available");
    expect(collectStep.minRequired).toBe(2);
  });
});

describe("router execution", () => {
  it("should select by index from candidates", async () => {
    const routerStep: PipelineStep = {
      kind: "router",
      in: "candidates",
      selectionIn: "selection",
      selectionType: "index",
      selectionProperty: "winner",
      out: "best",
    };

    expect(routerStep.selectionType).toBe("index");
    expect(routerStep.selectionProperty).toBe("winner");
  });

  it("should select by property match from candidates", async () => {
    const routerStep: PipelineStep = {
      kind: "router",
      in: "candidates",
      selectionIn: "selection",
      selectionType: "property",
      selectionProperty: "selectedId",
      out: "best",
    };

    expect(routerStep.selectionType).toBe("property");
  });
});

describe("integration: full iterative workflow", () => {
  it("should correctly order a logo variation workflow", () => {
    // Logo variation workflow: text → fan-out → generators → collect → vision → router
    const steps: PipelineStep[] = [
      // Text node generates prompts
      {
        kind: "text",
        provider: "openai",
        params: { prompt: "Generate 3 logo concepts" },
        out: "concepts",
      },
      // Fan-out the prompts
      {
        kind: "fan-out",
        in: "concepts",
        mode: "array",
        arrayProperty: "concepts",
        out: ["prompt_0", "prompt_1", "prompt_2"],
      },
      // Generate logos in parallel (would be generate steps in real workflow)
      { kind: "generate", generator: "dall-e-3", out: "logo_0" },
      { kind: "generate", generator: "dall-e-3", out: "logo_1" },
      { kind: "generate", generator: "dall-e-3", out: "logo_2" },
      // Collect all logos
      {
        kind: "collect",
        in: ["logo_0", "logo_1", "logo_2"],
        waitMode: "all",
        out: "all_logos",
      },
      // Vision evaluates (simulated as text)
      {
        kind: "text",
        provider: "openai",
        in: "all_logos",
        params: { prompt: "Which is best?" },
        out: "evaluation",
      },
      // Router selects winner
      {
        kind: "router",
        in: "all_logos",
        selectionIn: "evaluation",
        selectionType: "index",
        selectionProperty: "winner",
        out: "best_logo",
      },
      // Save the winner
      {
        kind: "save",
        in: "best_logo",
        destination: "./output/best-logo.png",
      },
    ];

    const graph = buildDependencyGraph(steps);
    const waves = computeExecutionWaves(graph);

    // Verify the workflow compiles without circular dependency errors
    expect(waves.length).toBeGreaterThan(0);

    // Verify router comes after both collect and evaluation
    const routerWaveIndex = waves.findIndex((w) => w.steps.some((s) => s.step.kind === "router"));
    const collectWaveIndex = waves.findIndex((w) => w.steps.some((s) => s.step.kind === "collect"));
    const evalWaveIndex = waves.findIndex((w) =>
      w.steps.some((s) => s.step.kind === "text" && s.step.out === "evaluation")
    );

    expect(routerWaveIndex).toBeGreaterThan(collectWaveIndex);
    expect(routerWaveIndex).toBeGreaterThan(evalWaveIndex);
  });
});

// =============================================================================
// Integration Tests with FloImg Client
// =============================================================================

describe("FloImg client: branching execution", () => {
  let client: FloImg;
  let generatedImages: string[];

  beforeEach(() => {
    client = new FloImg({ verbose: false });
    generatedImages = [];

    // Register mock generator that tracks calls
    const mockGenerator: ImageGenerator = {
      name: "mock-gen",
      schema: {
        name: "mock-gen",
        description: "Mock generator for testing",
        parameters: {},
      },
      generate: async (params) => {
        const id = params.id || `img-${generatedImages.length}`;
        generatedImages.push(id as string);
        return mockImageBlob(id as string);
      },
    };
    client.registerGenerator(mockGenerator);

    // Register mock text provider
    const mockTextProvider: TextProvider = {
      name: "mock-text",
      schema: {
        name: "mock-text",
        description: "Mock text provider for testing",
        parameters: {},
      },
      generate: async (params) => {
        // Return predefined JSON based on prompt
        const prompt = params.prompt as string;
        if (prompt?.includes("concepts")) {
          return mockDataBlob(
            JSON.stringify({ concepts: ["concept-a", "concept-b", "concept-c"] }),
            { concepts: ["concept-a", "concept-b", "concept-c"] }
          );
        }
        if (prompt?.includes("winner") || prompt?.includes("pick") || prompt?.includes("best")) {
          return mockDataBlob(JSON.stringify({ winner: 1, reasoning: "Best composition" }), {
            winner: 1,
            reasoning: "Best composition",
          });
        }
        return mockDataBlob("default response");
      },
    };
    client.registerTextProvider(mockTextProvider);
  });

  describe("fan-out execution", () => {
    it("should distribute input to branches in count mode", async () => {
      const pipeline: Pipeline = {
        name: "fan-out-count-test",
        steps: [
          { kind: "generate", generator: "mock-gen", params: { id: "source" }, out: "source" },
          {
            kind: "fan-out",
            in: "source",
            mode: "count",
            count: 3,
            out: ["b_0", "b_1", "b_2"],
          },
        ],
      };

      const results = await client.run(pipeline);

      // Fan-out should have distributed the source to all branches
      expect(results).toHaveLength(2);
      expect(results[1].step.kind).toBe("fan-out");
    });

    it("should distribute array items in array mode", async () => {
      const pipeline: Pipeline = {
        name: "fan-out-array-test",
        steps: [
          {
            kind: "text",
            provider: "mock-text",
            params: { prompt: "Generate concepts" },
            out: "concepts",
          },
          {
            kind: "fan-out",
            in: "concepts",
            mode: "array",
            arrayProperty: "concepts",
            out: ["c_0", "c_1", "c_2"],
          },
        ],
      };

      const results = await client.run(pipeline);

      expect(results).toHaveLength(2);
      expect(results[1].step.kind).toBe("fan-out");
    });
  });

  describe("collect execution", () => {
    it("should gather all branch outputs", async () => {
      const pipeline: Pipeline = {
        name: "collect-test",
        initialVariables: {
          img_0: mockImageBlob("0"),
          img_1: mockImageBlob("1"),
          img_2: mockImageBlob("2"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1", "img_2"],
            waitMode: "all",
            out: "collected",
          },
        ],
      };

      const results = await client.run(pipeline);

      expect(results).toHaveLength(1);
      expect(results[0].step.kind).toBe("collect");

      // Verify the collected result has metadata
      const collectResult = results[0].value as DataBlob;
      expect(collectResult.metadata?.validCount).toBe(3);
    });

    it("should fail if waitMode='all' and input is missing", async () => {
      const pipeline: Pipeline = {
        name: "collect-fail-test",
        initialVariables: {
          img_0: mockImageBlob("0"),
          // img_1 missing!
          img_2: mockImageBlob("2"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1", "img_2"],
            waitMode: "all",
            out: "collected",
          },
        ],
      };

      // With waitMode="all", the dependency analysis catches missing inputs
      // before execution even starts - this is correct behavior
      await expect(client.run(pipeline)).rejects.toThrow(/missing input|Unsatisfied/i);
    });

    it("should work with waitMode='available' when all inputs present", async () => {
      // Note: waitMode="available" vs "all" differs at execution time, not dependency analysis.
      // Both modes require all dependencies to be satisfied in the graph.
      // The difference: "all" throws if any input is undefined during execution,
      // while "available" accepts partial results.
      const pipeline: Pipeline = {
        name: "collect-available-test",
        initialVariables: {
          img_0: mockImageBlob("0"),
          img_1: mockImageBlob("1"),
          img_2: mockImageBlob("2"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1", "img_2"],
            waitMode: "available",
            minRequired: 2,
            out: "collected",
          },
        ],
      };

      const results = await client.run(pipeline);

      expect(results).toHaveLength(1);
      const collectResult = results[0].value as DataBlob;
      expect(collectResult.metadata?.validCount).toBe(3);
    });
  });

  describe("router execution", () => {
    it("should select by index from collected array", async () => {
      const pipeline: Pipeline = {
        name: "router-index-test",
        initialVariables: {
          img_0: mockImageBlob("zero"),
          img_1: mockImageBlob("one"),
          img_2: mockImageBlob("two"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1", "img_2"],
            waitMode: "all",
            out: "candidates",
          },
          {
            kind: "text",
            provider: "mock-text",
            params: { prompt: "pick the best" },
            out: "selection",
          },
          {
            kind: "router",
            in: "candidates",
            selectionIn: "selection",
            selectionType: "index",
            selectionProperty: "winner",
            out: "winner",
          },
        ],
      };

      const results = await client.run(pipeline);

      // Router should have selected index 1 (as returned by mock)
      const routerResult = results.find((r) => r.step.kind === "router");
      expect(routerResult).toBeDefined();

      const selectedImage = routerResult!.value as ImageBlob;
      expect(selectedImage.source).toBe("test:one"); // Index 1 = "one"
    });

    it("should throw on out-of-bounds index", async () => {
      // Create a mock text provider that returns out-of-bounds index
      const badTextProvider: TextProvider = {
        name: "bad-text",
        schema: { name: "bad-text", parameters: {} },
        generate: async () => mockDataBlob(JSON.stringify({ winner: 99 }), { winner: 99 }),
      };
      client.registerTextProvider(badTextProvider);

      const pipeline: Pipeline = {
        name: "router-oob-test",
        initialVariables: {
          img_0: mockImageBlob("zero"),
          img_1: mockImageBlob("one"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1"],
            waitMode: "all",
            out: "candidates",
          },
          {
            kind: "text",
            provider: "bad-text",
            params: { prompt: "pick" },
            out: "selection",
          },
          {
            kind: "router",
            in: "candidates",
            selectionIn: "selection",
            selectionType: "index",
            selectionProperty: "winner",
            out: "winner",
          },
        ],
      };

      await expect(client.run(pipeline)).rejects.toThrow(/out of bounds/);
    });
  });

  describe("edge cases", () => {
    it("should handle fan-out with count=1 (degenerate case)", async () => {
      const pipeline: Pipeline = {
        name: "single-branch-test",
        steps: [
          { kind: "generate", generator: "mock-gen", params: { id: "source" }, out: "source" },
          {
            kind: "fan-out",
            in: "source",
            mode: "count",
            count: 1,
            out: ["only_branch"],
          },
        ],
      };

      const results = await client.run(pipeline);
      expect(results).toHaveLength(2);
    });

    it("should handle collect with single input", async () => {
      const pipeline: Pipeline = {
        name: "single-collect-test",
        initialVariables: {
          img_0: mockImageBlob("only"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0"],
            waitMode: "all",
            out: "collected",
          },
        ],
      };

      const results = await client.run(pipeline);
      const collectResult = results[0].value as DataBlob;
      expect(collectResult.metadata?.validCount).toBe(1);
    });

    it("should handle empty array in fan-out array mode", async () => {
      // Create text provider that returns empty array
      const emptyTextProvider: TextProvider = {
        name: "empty-text",
        schema: { name: "empty-text", parameters: {} },
        generate: async () => mockDataBlob(JSON.stringify({ items: [] }), { items: [] }),
      };
      client.registerTextProvider(emptyTextProvider);

      const pipeline: Pipeline = {
        name: "empty-array-test",
        steps: [
          {
            kind: "text",
            provider: "empty-text",
            params: { prompt: "empty" },
            out: "data",
          },
          {
            kind: "fan-out",
            in: "data",
            mode: "array",
            arrayProperty: "items",
            out: ["item_0", "item_1"], // More outputs than items
          },
        ],
      };

      // Should complete without error, just no outputs populated
      const results = await client.run(pipeline);
      expect(results).toHaveLength(2);
    });

    it("should handle router with index 0 (first item)", async () => {
      // Create text provider that returns index 0
      const firstTextProvider: TextProvider = {
        name: "first-text",
        schema: { name: "first-text", parameters: {} },
        generate: async () => mockDataBlob(JSON.stringify({ winner: 0 }), { winner: 0 }),
      };
      client.registerTextProvider(firstTextProvider);

      const pipeline: Pipeline = {
        name: "first-index-test",
        initialVariables: {
          img_0: mockImageBlob("first"),
          img_1: mockImageBlob("second"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1"],
            waitMode: "all",
            out: "candidates",
          },
          {
            kind: "text",
            provider: "first-text",
            params: { prompt: "pick" },
            out: "selection",
          },
          {
            kind: "router",
            in: "candidates",
            selectionIn: "selection",
            selectionType: "index",
            selectionProperty: "winner",
            out: "winner",
          },
        ],
      };

      const results = await client.run(pipeline);
      const routerResult = results.find((r) => r.step.kind === "router");
      const selected = routerResult!.value as ImageBlob;
      expect(selected.source).toBe("test:first");
    });

    it("should fail gracefully if fan-out arrayProperty not found", async () => {
      const pipeline: Pipeline = {
        name: "missing-property-test",
        initialVariables: {
          data: mockDataBlob(JSON.stringify({ wrongKey: ["a", "b"] }), { wrongKey: ["a", "b"] }),
        },
        steps: [
          {
            kind: "fan-out",
            in: "data",
            mode: "array",
            arrayProperty: "items", // Wrong property name
            out: ["item_0", "item_1"],
          },
        ],
      };

      await expect(client.run(pipeline)).rejects.toThrow(/not an array/);
    });

    it("should fail if router selectionProperty is missing from selection data", async () => {
      // Create text provider that returns wrong property
      const wrongPropProvider: TextProvider = {
        name: "wrong-prop",
        schema: { name: "wrong-prop", parameters: {} },
        generate: async () => mockDataBlob(JSON.stringify({ choice: 1 }), { choice: 1 }), // 'choice' not 'winner'
      };
      client.registerTextProvider(wrongPropProvider);

      const pipeline: Pipeline = {
        name: "wrong-selection-prop-test",
        initialVariables: {
          img_0: mockImageBlob("a"),
          img_1: mockImageBlob("b"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1"],
            waitMode: "all",
            out: "candidates",
          },
          {
            kind: "text",
            provider: "wrong-prop",
            params: { prompt: "pick" },
            out: "selection",
          },
          {
            kind: "router",
            in: "candidates",
            selectionIn: "selection",
            selectionType: "index",
            selectionProperty: "winner", // Looking for 'winner' but got 'choice'
            out: "winner",
          },
        ],
      };

      // Should fail because selectionProperty doesn't exist in selection data
      await expect(client.run(pipeline)).rejects.toThrow(/not found in selection data/);
    });

    it("should handle collect minRequired equal to actual count", async () => {
      const pipeline: Pipeline = {
        name: "exact-min-test",
        initialVariables: {
          img_0: mockImageBlob("0"),
          img_1: mockImageBlob("1"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1"],
            waitMode: "available",
            minRequired: 2, // Exactly matches input count
            out: "collected",
          },
        ],
      };

      const results = await client.run(pipeline);
      const collectResult = results[0].value as DataBlob;
      expect(collectResult.metadata?.validCount).toBe(2);
    });

    it("should fail if collect minRequired exceeds available inputs", async () => {
      // This tests the minRequired validation at execution time.
      // We need all dependencies satisfied in the graph, but can test minRequired
      // by having fewer inputs satisfy the threshold.
      const pipeline: Pipeline = {
        name: "insufficient-min-test",
        initialVariables: {
          img_0: mockImageBlob("0"),
          img_1: mockImageBlob("1"),
        },
        steps: [
          {
            kind: "collect",
            in: ["img_0", "img_1"],
            waitMode: "available",
            minRequired: 3, // Need 3 but only have 2
            out: "collected",
          },
        ],
      };

      await expect(client.run(pipeline)).rejects.toThrow(/at least 3 inputs/);
    });
  });

  describe("parallel execution verification", () => {
    it("should execute independent branches in parallel", async () => {
      const executionOrder: string[] = [];
      const executionTimes: Record<string, number> = {};

      // Create a slow generator that tracks execution timing
      const slowGenerator: ImageGenerator = {
        name: "slow-gen",
        schema: { name: "slow-gen", description: "Slow for testing", parameters: {} },
        generate: async (params) => {
          const id = params.id as string;
          executionOrder.push(`start:${id}`);
          executionTimes[`start:${id}`] = Date.now();

          // Simulate async work
          await new Promise((r) => setTimeout(r, 10));

          executionOrder.push(`end:${id}`);
          executionTimes[`end:${id}`] = Date.now();
          return mockImageBlob(id);
        },
      };
      client.registerGenerator(slowGenerator);

      const pipeline: Pipeline = {
        name: "parallel-test",
        steps: [
          // These three generators have no dependencies - should run in parallel
          { kind: "generate", generator: "slow-gen", params: { id: "a" }, out: "a" },
          { kind: "generate", generator: "slow-gen", params: { id: "b" }, out: "b" },
          { kind: "generate", generator: "slow-gen", params: { id: "c" }, out: "c" },
          // This depends on all three - should run after
          {
            kind: "collect",
            in: ["a", "b", "c"],
            waitMode: "all",
            out: "collected",
          },
        ],
      };

      await client.run(pipeline);

      // All three should start before any end (parallel execution)
      const startIndexA = executionOrder.indexOf("start:a");
      const startIndexB = executionOrder.indexOf("start:b");
      const startIndexC = executionOrder.indexOf("start:c");
      const endIndexA = executionOrder.indexOf("end:a");
      const endIndexB = executionOrder.indexOf("end:b");
      const endIndexC = executionOrder.indexOf("end:c");

      // All starts should happen before all ends (parallel)
      expect(startIndexA).toBeLessThan(endIndexA);
      expect(startIndexB).toBeLessThan(endIndexB);
      expect(startIndexC).toBeLessThan(endIndexC);

      // The starts should be interleaved (not strictly sequential)
      // In parallel execution, we expect: start:a, start:b, start:c, end:a, end:b, end:c
      // In sequential, it would be: start:a, end:a, start:b, end:b, start:c, end:c
      expect(Math.max(startIndexA, startIndexB, startIndexC)).toBeLessThan(
        Math.min(endIndexA, endIndexB, endIndexC)
      );
    });

    it("should respect dependencies and execute sequentially when needed", async () => {
      const executionOrder: string[] = [];

      const trackingGenerator: ImageGenerator = {
        name: "track-gen",
        schema: { name: "track-gen", description: "Tracking", parameters: {} },
        generate: async (params) => {
          const id = params.id as string;
          executionOrder.push(id);
          return mockImageBlob(id);
        },
      };
      client.registerGenerator(trackingGenerator);

      const pipeline: Pipeline = {
        name: "sequential-test",
        steps: [
          // First: no dependencies
          { kind: "generate", generator: "track-gen", params: { id: "first" }, out: "first" },
          // Second: depends on first (via fan-out)
          {
            kind: "fan-out",
            in: "first",
            mode: "count",
            count: 2,
            out: ["branch_0", "branch_1"],
          },
          // Third & Fourth: depend on fan-out
          { kind: "generate", generator: "track-gen", params: { id: "third" }, out: "third" },
          { kind: "generate", generator: "track-gen", params: { id: "fourth" }, out: "fourth" },
          // Fifth: depends on third and fourth
          {
            kind: "collect",
            in: ["third", "fourth"],
            waitMode: "all",
            out: "collected",
          },
        ],
      };

      await client.run(pipeline);

      // "first" should come before everything else
      expect(executionOrder.indexOf("first")).toBe(0);

      // "third" and "fourth" should come after "first" but can be in any order relative to each other
      expect(executionOrder.indexOf("third")).toBeGreaterThan(0);
      expect(executionOrder.indexOf("fourth")).toBeGreaterThan(0);
    });

    it("should handle concurrency limit", async () => {
      let currentlyRunning = 0;
      let maxConcurrent = 0;

      const concurrencyTrackingGenerator: ImageGenerator = {
        name: "conc-gen",
        schema: { name: "conc-gen", description: "Concurrency tracking", parameters: {} },
        generate: async (params) => {
          currentlyRunning++;
          maxConcurrent = Math.max(maxConcurrent, currentlyRunning);

          await new Promise((r) => setTimeout(r, 10));

          currentlyRunning--;
          return mockImageBlob(params.id as string);
        },
      };
      client.registerGenerator(concurrencyTrackingGenerator);

      const pipeline: Pipeline = {
        name: "concurrency-test",
        concurrency: 2, // Limit to 2 concurrent steps
        steps: [
          { kind: "generate", generator: "conc-gen", params: { id: "a" }, out: "a" },
          { kind: "generate", generator: "conc-gen", params: { id: "b" }, out: "b" },
          { kind: "generate", generator: "conc-gen", params: { id: "c" }, out: "c" },
          { kind: "generate", generator: "conc-gen", params: { id: "d" }, out: "d" },
        ],
      };

      await client.run(pipeline);

      // Should never exceed concurrency limit of 2
      expect(maxConcurrent).toBeLessThanOrEqual(2);
      // But should use parallelism (at least 2 ran together at some point)
      expect(maxConcurrent).toBe(2);
    });
  });

  describe("full workflow: fan-out → collect → router", () => {
    it("should execute complete iterative workflow", async () => {
      const pipeline: Pipeline = {
        name: "full-iterative-test",
        steps: [
          // Generate source image
          {
            kind: "generate",
            generator: "mock-gen",
            params: { id: "source" },
            out: "source",
          },
          // Fan-out to 3 branches
          {
            kind: "fan-out",
            in: "source",
            mode: "count",
            count: 3,
            out: ["b_0", "b_1", "b_2"],
          },
          // Simulate transforms on each branch (just re-generate for test)
          {
            kind: "generate",
            generator: "mock-gen",
            params: { id: "variant-0" },
            out: "v_0",
          },
          {
            kind: "generate",
            generator: "mock-gen",
            params: { id: "variant-1" },
            out: "v_1",
          },
          {
            kind: "generate",
            generator: "mock-gen",
            params: { id: "variant-2" },
            out: "v_2",
          },
          // Collect results
          {
            kind: "collect",
            in: ["v_0", "v_1", "v_2"],
            waitMode: "all",
            out: "all_variants",
          },
          // Evaluate
          {
            kind: "text",
            provider: "mock-text",
            params: { prompt: "pick the winner" },
            out: "evaluation",
          },
          // Route to winner
          {
            kind: "router",
            in: "all_variants",
            selectionIn: "evaluation",
            selectionType: "index",
            selectionProperty: "winner",
            out: "best",
          },
        ],
      };

      const results = await client.run(pipeline);

      // Verify all steps executed
      const stepKinds = results.map((r) => r.step.kind);
      expect(stepKinds).toContain("generate");
      expect(stepKinds).toContain("fan-out");
      expect(stepKinds).toContain("collect");
      expect(stepKinds).toContain("text");
      expect(stepKinds).toContain("router");

      // Verify router selected the correct variant (index 1)
      const routerResult = results.find((r) => r.step.kind === "router");
      const selectedImage = routerResult!.value as ImageBlob;
      expect(selectedImage.source).toBe("test:variant-1");

      // Verify generators were called in parallel (4 total: source + 3 variants)
      expect(generatedImages).toHaveLength(4);
    });
  });
});
